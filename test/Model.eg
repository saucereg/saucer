
require-macros:
   earl-mocha ->
      describe, it, before, after
      xdescribe, xit
      assert, asserts

require:
   underscore -> {size, debounce}
   ../src/Saucer

init-one-col = Saucer.Collection()

class InitOneModel < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
   initialize = ->
      @one = 1
      assert @collection == init-one-col

class InitTwoModel < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
   initialize = (attributes, options) ->
      @one = options.one

class InitParseModel < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
   parse = attrs -> [attrs.value += 1; attrs]

class InitDefaultModel < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
   defaults = {
      first-name = .Unknown
      last-name  = .Unknown
   }

class ParseNullModel < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
   parse = attrs -> [attrs.value += 1; null]

describe "Saucer.Model":

   it "initializes":
      m = InitOneModel({=}, {collection = init-one-col})
      assert m.one == 1
      assert m.collection == init-one-col

   it "initializes with attributes and options":
      m = InitTwoModel({=}, {one = 1})
      assert m.one == 1

   it "initializes with parsed attributes":
      m = InitParseModel({value = 1}, {parse = true})
      assert m.get(.value) == 2

   it "initializes with defaults":
      m = InitDefaultModel({first-name = .John})
      assert m.get(.first-name) == .John
      assert m.get(.last-name)  == .Unknown

   it "can return null with `parse`":
      m = ParseNullModel({value = 1}, {parse = true})
      assert JSON.stringify(m.to-JSON()) == "{}"


class Proxy < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
class Klass < Saucer.Collection:
   constructor() = Saucer.Collection.apply(@, arguments)
   url = -> "/collection"
class UrlRootModel < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
   url-root = '/collection'
class UrlRootFnModel < Saucer.Model:
   constructor() = Saucer.Model.apply(@, arguments)
   url-root = -> '/nested/{@get(.parent-id)}/collection'

describe "Saucer.Model.url()":
   before:
      @doc = Proxy() with {
         id     = '1-the-tempest'
         title  = "The Tempest"
         author = "Bill Shakespeare"
         length = 123
      }
      @collection = Klass();
      @collection.add(@doc);

   it "builds model representations as urls":
      @doc.url-root = null
      assert @doc.url() == "/collection/1-the-tempest"
      @doc.collection.url = "/collection/"
      assert @doc.url() == "/collection/1-the-tempest"
      @doc.collection = null
      try:
         @doc.url()
      catch e:
         assert not undefined? e
      @doc.collection = @collection

   it "can be used with url-root and url-encoding":
      m = UrlRootModel()
      assert m.url() == '/collection'
      m.set({id = "+1+"})
      assert m.url() == '/collection/%2B1%2B'

   it "can access url-root as a function":
      m = UrlRootFnModel({parent-id = 1})
      assert m.url() == '/nested/1/collection'
      m.set({id = 2})
      assert m.url() == '/nested/1/collection/2'
